import { int, mysqlEnum, mysqlTable, text, timestamp, varchar } from "drizzle-orm/mysql-core";

/**
 * Core user table backing auth flow.
 * Extend this file with additional tables as your product grows.
 * Columns use camelCase to match both database fields and generated types.
 */
export const users = mysqlTable("users", {
  /**
   * Surrogate primary key. Auto-incremented numeric value managed by the database.
   * Use this for relations between tables.
   */
  id: int("id").autoincrement().primaryKey(),
  /** Manus OAuth identifier (openId) returned from the OAuth callback. Unique per user. */
  openId: varchar("openId", { length: 64 }).notNull().unique(),
  name: text("name"),
  email: varchar("email", { length: 320 }),
  loginMethod: varchar("loginMethod", { length: 64 }),
  role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  lastSignedIn: timestamp("lastSignedIn").defaultNow().notNull(),
});

export type User = typeof users.$inferSelect;
export type InsertUser = typeof users.$inferInsert;

/**
 * Projects table - stores user-created applications
 */
export const projects = mysqlTable("projects", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  status: mysqlEnum("status", ["draft", "generating", "ready", "deploying", "deployed", "failed"]).default("draft").notNull(),
  templateId: int("templateId"),
  deploymentProvider: mysqlEnum("deploymentProvider", ["vercel", "railway", "kubernetes"]).default("vercel"),
  githubRepoUrl: varchar("githubRepoUrl", { length: 500 }),
  isImported: int("isImported").default(0), // 0 = new project, 1 = imported from existing repo
  deploymentUrl: varchar("deploymentUrl", { length: 500 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Project = typeof projects.$inferSelect;
export type InsertProject = typeof projects.$inferInsert;

/**
 * Conversations table - stores AI chat history for project generation
 */
export const conversations = mysqlTable("conversations", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  role: mysqlEnum("role", ["user", "assistant", "system"]).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Conversation = typeof conversations.$inferSelect;
export type InsertConversation = typeof conversations.$inferInsert;

/**
 * Generated files table - stores code files generated by AI
 */
export const generatedFiles = mysqlTable("generatedFiles", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  filePath: varchar("filePath", { length: 500 }).notNull(),
  content: text("content").notNull(),
  language: varchar("language", { length: 50 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type GeneratedFile = typeof generatedFiles.$inferSelect;
export type InsertGeneratedFile = typeof generatedFiles.$inferInsert;

/**
 * Deployments table - tracks deployment history and status
 */
export const deployments = mysqlTable("deployments", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  provider: mysqlEnum("provider", ["vercel", "railway", "kubernetes"]).default("vercel").notNull(),
  providerDeploymentId: varchar("providerDeploymentId", { length: 255 }),
  status: mysqlEnum("status", ["pending", "building", "deploying", "success", "failed"]).default("pending").notNull(),
  deploymentUrl: varchar("deploymentUrl", { length: 500 }),
  logs: text("logs"),
  errorMessage: text("errorMessage"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  completedAt: timestamp("completedAt"),
});

export type Deployment = typeof deployments.$inferSelect;
export type InsertDeployment = typeof deployments.$inferInsert;

/**
 * Templates table - predefined project templates
 */
export const templates = mysqlTable("templates", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  category: varchar("category", { length: 100 }),
  icon: varchar("icon", { length: 100 }),
  techStack: text("techStack"),
  isActive: int("isActive").default(1).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type Template = typeof templates.$inferSelect;
export type InsertTemplate = typeof templates.$inferInsert;

/**
 * Provisioned databases for projects
 */
export const provisionedDatabases = mysqlTable("provisioned_databases", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  type: mysqlEnum("type", ["postgresql", "mysql", "mongodb", "redis"]).notNull(),
  name: varchar("name", { length: 255 }).notNull(),
  host: varchar("host", { length: 255 }).notNull(),
  port: int("port").notNull(),
  username: varchar("username", { length: 255 }).notNull(),
  password: varchar("password", { length: 255 }).notNull(),
  database: varchar("database", { length: 255 }).notNull(),
  status: mysqlEnum("status", ["provisioning", "active", "failed", "deleted"]).default("provisioning").notNull(),
  connectionString: text("connectionString"),
  size: varchar("size", { length: 50 }).default("small"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type ProvisionedDatabase = typeof provisionedDatabases.$inferSelect;
export type InsertProvisionedDatabase = typeof provisionedDatabases.$inferInsert;

/**
 * LLM API usage tracking for cost monitoring
 */
export const llmApiCalls = mysqlTable("llm_api_calls", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  projectId: int("projectId").references(() => projects.id),
  feature: mysqlEnum("feature", ["code_generation", "codebase_analysis", "code_modification", "chat"]).notNull(),
  model: varchar("model", { length: 100 }).notNull(),
  promptTokens: int("promptTokens").notNull(),
  completionTokens: int("completionTokens").notNull(),
  totalTokens: int("totalTokens").notNull(),
  estimatedCost: int("estimatedCost").notNull(), // Cost in cents (e.g., 150 = $1.50)
  responseTime: int("responseTime"), // Response time in milliseconds
  success: int("success").default(1).notNull(), // 1 = success, 0 = failed
  errorMessage: text("errorMessage"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type LlmApiCall = typeof llmApiCalls.$inferSelect;
export type InsertLlmApiCall = typeof llmApiCalls.$inferInsert;

/**
 * User cost summary for quick lookups
 */
export const userCostSummary = mysqlTable("user_cost_summary", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().unique().references(() => users.id),
  totalCalls: int("totalCalls").default(0).notNull(),
  totalTokens: int("totalTokens").default(0).notNull(),
  totalCost: int("totalCost").default(0).notNull(), // Cost in cents
  monthlyCallsCount: int("monthlyCallsCount").default(0).notNull(),
  monthlyCost: int("monthlyCost").default(0).notNull(), // Cost in cents for current month
  lastCallAt: timestamp("lastCallAt"),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type UserCostSummary = typeof userCostSummary.$inferSelect;
export type InsertUserCostSummary = typeof userCostSummary.$inferInsert;

/**
 * Built-in deployments - tracks deployments on Project Catalyst's own infrastructure
 */
export const builtInDeployments = mysqlTable("built_in_deployments", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  userId: int("userId").notNull().references(() => users.id),
  containerId: varchar("containerId", { length: 255 }), // Docker container ID
  subdomain: varchar("subdomain", { length: 255 }).notNull().unique(), // e.g., "my-app" for my-app.catalyst.app
  deploymentUrl: varchar("deploymentUrl", { length: 500 }).notNull(), // Full URL
  status: mysqlEnum("status", ["pending", "building", "running", "stopped", "failed"]).default("pending").notNull(),
  buildLogs: text("buildLogs"),
  runtimeLogs: text("runtimeLogs"),
  errorMessage: text("errorMessage"),
  port: int("port"), // Internal container port
  cpuLimit: int("cpuLimit").default(1000), // CPU limit in millicores (1000 = 1 CPU)
  memoryLimit: int("memoryLimit").default(512), // Memory limit in MB
  storageLimit: int("storageLimit").default(1024), // Storage limit in MB
  healthCheckUrl: varchar("healthCheckUrl", { length: 500 }), // Health check endpoint
  lastHealthCheck: timestamp("lastHealthCheck"),
  healthStatus: mysqlEnum("healthStatus", ["healthy", "unhealthy", "unknown"]).default("unknown"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
  stoppedAt: timestamp("stoppedAt"),
});

export type BuiltInDeployment = typeof builtInDeployments.$inferSelect;
export type InsertBuiltInDeployment = typeof builtInDeployments.$inferInsert;

/**
 * Deployment logs - stores streaming logs from deployments
 */
export const deploymentLogs = mysqlTable("deployment_logs", {
  id: int("id").autoincrement().primaryKey(),
  deploymentId: int("deploymentId").notNull().references(() => builtInDeployments.id),
  logType: mysqlEnum("logType", ["build", "runtime", "error"]).notNull(),
  message: text("message").notNull(),
  timestamp: timestamp("timestamp").defaultNow().notNull(),
});

export type DeploymentLog = typeof deploymentLogs.$inferSelect;
export type InsertDeploymentLog = typeof deploymentLogs.$inferInsert;

/**
 * Custom domains - stores custom domain configurations for deployments
 */
export const customDomains = mysqlTable("custom_domains", {
  id: int("id").autoincrement().primaryKey(),
  deploymentId: int("deploymentId").notNull().references(() => builtInDeployments.id),
  domain: varchar("domain", { length: 255 }).notNull().unique(),
  status: mysqlEnum("status", ["pending", "verifying", "active", "failed"]).default("pending").notNull(),
  sslStatus: mysqlEnum("sslStatus", ["none", "pending", "active", "expired", "failed"]).default("none").notNull(),
  sslCertificate: text("sslCertificate"), // SSL certificate content
  sslPrivateKey: text("sslPrivateKey"), // SSL private key (encrypted)
  sslExpiresAt: timestamp("sslExpiresAt"),
  verificationToken: varchar("verificationToken", { length: 255 }), // For domain verification
  verifiedAt: timestamp("verifiedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CustomDomain = typeof customDomains.$inferSelect;
export type InsertCustomDomain = typeof customDomains.$inferInsert;

/**
 * Deployment environment variables - stores env vars for deployments
 */
export const deploymentEnvVars = mysqlTable("deployment_env_vars", {
  id: int("id").autoincrement().primaryKey(),
  deploymentId: int("deploymentId").notNull().references(() => builtInDeployments.id),
  key: varchar("key", { length: 255 }).notNull(),
  value: text("value").notNull(), // Should be encrypted in production
  isSecret: int("isSecret").default(0).notNull(), // 0 = public, 1 = secret (masked in UI)
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type DeploymentEnvVar = typeof deploymentEnvVars.$inferSelect;
export type InsertDeploymentEnvVar = typeof deploymentEnvVars.$inferInsert;
/**
 * Cost alerts - configurable alerts for cost thresholds
 */
export const costAlerts = mysqlTable("cost_alerts", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  alertType: mysqlEnum("alertType", ["daily", "weekly", "monthly", "total"]).notNull(),
  threshold: int("threshold").notNull(), // Threshold in cents
  currentValue: int("currentValue").default(0).notNull(), // Current value in cents
  isActive: int("isActive").default(1).notNull(), // 1 = active, 0 = disabled
  lastTriggeredAt: timestamp("lastTriggeredAt"),
  notificationMethod: mysqlEnum("notificationMethod", ["email", "dashboard", "both"]).default("both").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type CostAlert = typeof costAlerts.$inferSelect;
export type InsertCostAlert = typeof costAlerts.$inferInsert;

/**
 * Cost alert history - tracks when alerts were triggered
 */
export const costAlertHistory = mysqlTable("cost_alert_history", {
  id: int("id").autoincrement().primaryKey(),
  alertId: int("alertId").notNull().references(() => costAlerts.id),
  userId: int("userId").notNull().references(() => users.id),
  threshold: int("threshold").notNull(),
  actualValue: int("actualValue").notNull(),
  message: text("message").notNull(),
  acknowledged: int("acknowledged").default(0).notNull(), // 1 = user acknowledged, 0 = not acknowledged
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type CostAlertHistoryEntry = typeof costAlertHistory.$inferSelect;
export type InsertCostAlertHistoryEntry = typeof costAlertHistory.$inferInsert;

/**
 * Usage analytics - tracks various platform usage metrics
 */
export const usageAnalytics = mysqlTable("usage_analytics", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  date: varchar("date", { length: 10 }).notNull(), // Format: YYYY-MM-DD
  projectsCreated: int("projectsCreated").default(0).notNull(),
  codeGenerations: int("codeGenerations").default(0).notNull(),
  deploymentsTriggered: int("deploymentsTriggered").default(0).notNull(),
  githubCommits: int("githubCommits").default(0).notNull(),
  aiTokensUsed: int("aiTokensUsed").default(0).notNull(),
  costIncurred: int("costIncurred").default(0).notNull(), // Cost in cents
  activeMinutes: int("activeMinutes").default(0).notNull(), // Time spent actively using platform
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type UsageAnalytics = typeof usageAnalytics.$inferSelect;
export type InsertUsageAnalytics = typeof usageAnalytics.$inferInsert;

/**
 * Fair use policy violations - tracks users exceeding fair use limits
 */
export const fairUsePolicyViolations = mysqlTable("fair_use_policy_violations", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  violationType: mysqlEnum("violationType", [
    "daily_cost_limit",
    "monthly_cost_limit",
    "rate_limit",
    "abuse_detected",
    "suspicious_activity"
  ]).notNull(),
  description: text("description").notNull(),
  severity: mysqlEnum("severity", ["warning", "critical"]).notNull(),
  actionTaken: mysqlEnum("actionTaken", ["none", "warning_sent", "rate_limited", "account_suspended"]).default("none").notNull(),
  resolved: int("resolved").default(0).notNull(), // 1 = resolved, 0 = active
  resolvedAt: timestamp("resolvedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type FairUsePolicyViolation = typeof fairUsePolicyViolations.$inferSelect;
export type InsertFairUsePolicyViolation = typeof fairUsePolicyViolations.$inferInsert;

/**
 * Billing records - tracks billing cycles and payments
 */
export const billingRecords = mysqlTable("billing_records", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  billingPeriodStart: timestamp("billingPeriodStart").notNull(),
  billingPeriodEnd: timestamp("billingPeriodEnd").notNull(),
  totalCost: int("totalCost").notNull(), // Cost in cents
  aiCost: int("aiCost").notNull(), // AI API costs in cents
  deploymentCost: int("deploymentCost").notNull(), // Deployment costs in cents
  databaseCost: int("databaseCost").notNull(), // Database costs in cents
  status: mysqlEnum("status", ["pending", "paid", "overdue", "waived"]).default("pending").notNull(),
  invoiceUrl: varchar("invoiceUrl", { length: 500 }),
  paidAt: timestamp("paidAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type BillingRecord = typeof billingRecords.$inferSelect;
export type InsertBillingRecord = typeof billingRecords.$inferInsert;

/**
 * Deployment environments - supports dev/staging/prod environments
 */
export const deploymentEnvironments = mysqlTable("deploy_envs", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  name: varchar("name", { length: 100 }).notNull(), // e.g., "Production", "Staging", "Development"
  type: mysqlEnum("type", ["development", "staging", "production"]).notNull(),
  branch: varchar("branch", { length: 255 }).notNull(), // Git branch to deploy from
  subdomain: varchar("subdomain", { length: 255 }).notNull().unique(), // e.g., "my-app-staging"
  deploymentUrl: varchar("deploymentUrl", { length: 500 }).notNull(),
  status: mysqlEnum("status", ["active", "inactive", "deploying", "failed"]).default("inactive").notNull(),
  autoDeployEnabled: int("autoDeployEnabled").default(0).notNull(), // 1 = auto-deploy on push, 0 = manual only
  lastDeployedAt: timestamp("lastDeployedAt"),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type DeploymentEnvironment = typeof deploymentEnvironments.$inferSelect;
export type InsertDeploymentEnvironment = typeof deploymentEnvironments.$inferInsert;

/**
 * Environment-specific variables - different env vars per environment
 */
export const environmentVariables = mysqlTable("env_vars", {
  id: int("id").autoincrement().primaryKey(),
  environmentId: int("environmentId").notNull().references(() => deploymentEnvironments.id),
  key: varchar("key", { length: 255 }).notNull(),
  value: text("value").notNull(), // Should be encrypted
  isSecret: int("isSecret").default(0).notNull(), // 1 = secret (masked in UI), 0 = public
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type EnvironmentVariable = typeof environmentVariables.$inferSelect;
export type InsertEnvironmentVariable = typeof environmentVariables.$inferInsert;

/**
 * Team collaboration - team management
 */
export const teams = mysqlTable("teams", {
  id: int("id").autoincrement().primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  ownerId: int("ownerId").notNull().references(() => users.id),
  plan: mysqlEnum("plan", ["free", "pro", "enterprise"]).default("free").notNull(),
  maxMembers: int("maxMembers").default(5).notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
  updatedAt: timestamp("updatedAt").defaultNow().onUpdateNow().notNull(),
});

export type Team = typeof teams.$inferSelect;
export type InsertTeam = typeof teams.$inferInsert;

/**
 * Team members - users belonging to teams
 */
export const teamMembers = mysqlTable("team_members", {
  id: int("id").autoincrement().primaryKey(),
  teamId: int("teamId").notNull().references(() => teams.id),
  userId: int("userId").notNull().references(() => users.id),
  role: mysqlEnum("role", ["owner", "admin", "member", "viewer"]).default("member").notNull(),
  invitedBy: int("invitedBy").references(() => users.id),
  joinedAt: timestamp("joinedAt").defaultNow().notNull(),
});

export type TeamMember = typeof teamMembers.$inferSelect;
export type InsertTeamMember = typeof teamMembers.$inferInsert;

/**
 * Team invitations - pending invites
 */
export const teamInvitations = mysqlTable("team_invitations", {
  id: int("id").autoincrement().primaryKey(),
  teamId: int("teamId").notNull().references(() => teams.id),
  email: varchar("email", { length: 320 }).notNull(),
  role: mysqlEnum("role", ["admin", "member", "viewer"]).default("member").notNull(),
  invitedBy: int("invitedBy").notNull().references(() => users.id),
  token: varchar("token", { length: 255 }).notNull().unique(),
  status: mysqlEnum("status", ["pending", "accepted", "expired", "cancelled"]).default("pending").notNull(),
  expiresAt: timestamp("expiresAt").notNull(),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type TeamInvitation = typeof teamInvitations.$inferSelect;
export type InsertTeamInvitation = typeof teamInvitations.$inferInsert;

/**
 * Project team access - which teams can access which projects
 */
export const projectTeamAccess = mysqlTable("project_team_access", {
  id: int("id").autoincrement().primaryKey(),
  projectId: int("projectId").notNull().references(() => projects.id),
  teamId: int("teamId").notNull().references(() => teams.id),
  accessLevel: mysqlEnum("accessLevel", ["read", "write", "admin"]).default("read").notNull(),
  grantedBy: int("grantedBy").notNull().references(() => users.id),
  grantedAt: timestamp("grantedAt").defaultNow().notNull(),
});

export type ProjectTeamAccess = typeof projectTeamAccess.$inferSelect;
export type InsertProjectTeamAccess = typeof projectTeamAccess.$inferInsert;

/**
 * Activity log - track team member activities
 */
export const activityLog = mysqlTable("activity_log", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("userId").notNull().references(() => users.id),
  teamId: int("teamId").references(() => teams.id),
  projectId: int("projectId").references(() => projects.id),
  action: varchar("action", { length: 100 }).notNull(), // e.g., "project.created", "deployment.started"
  details: text("details"), // JSON string with additional context
  ipAddress: varchar("ipAddress", { length: 45 }),
  userAgent: varchar("userAgent", { length: 500 }),
  createdAt: timestamp("createdAt").defaultNow().notNull(),
});

export type ActivityLog = typeof activityLog.$inferSelect;
export type InsertActivityLog = typeof activityLog.$inferInsert;
